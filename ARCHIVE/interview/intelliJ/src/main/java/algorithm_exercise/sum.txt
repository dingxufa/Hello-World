

AVL树是平衡二叉搜索树的鼻祖，它的平衡度也最好，左右高度差可以保证在「-1，0，1」，基于它的平衡性，它的查询时间复杂度可以
保证是O（log n）。但每个节点要额外保存一个平衡值，或者说是高度差。


红黑树一样也是平衡二叉搜索树，也是工业界最主要使用的二叉搜索平衡树。但平衡度红黑树没AVL那么好。也就是说，如果从高度差来说，
红黑树是大于AVL的，其实也就代表着它的实际查询时间(最坏情况)略逊于AVL的。数学证明红黑树的最大深度是2 * log2^ (n+1),
其实最差情况它从根到叶子的最长路可以是最短路的两倍，但也不是很差，所以它的查询时间复杂度也是O（log n）

B/B+ 树就是N叉（N-ary）平衡树了，每个节点可以有更多的孩子，新的值可以插在已有的节点里，而不需要改变树的高度，从而大量减少
重新平衡和数据迁移的次数，这非常适合做数据库索引这种需要持久化在磁盘，同时需要大量查询和插入操作的应用。

以上几种树都是有序的，如果你采用合适的算法遍历整个数，可以得到一个有序的列表。这也是为什么如果有数据库索引的情况下，
你order by你索引的值，就会速度特别快，因为它并没有给你真的排序，只是遍历树而已。

B- 树是一棵平衡树，与一般的平衡二叉树（AVL，红黑树等）不同的是，B- 树的每个节点最多可以拥有 m（m>=2）个元素，（m+1）个子节点，
并且所有的叶子节点位于同一层。B- 树的查找和插入的时间复杂度和二叉树一样，都是 O(logn)，但因为每个节点保存的元素比较多
（一般是几十个到几百个之间），树的高度比一般的二叉树要小很多，访问硬盘次数更少，在数据不能全部加载到内存的时候比一般的
二叉树效率要好。



* 类与类之间的关系
 * 1、依赖:形参|局部变量
 * 2、关联:属性
 * 		聚合:属性 整体与部分 不一致的生命周期 人与手
 *       组合:属性 整体与部分 一致的生命周期  人与大脑
 * 3、继承:父子类关系
 * 4、实现: 接口与实现类关系
==========
* 转换流: 字节转为字符
 * 1、输出流 OutputStreamWriter 编码
 * 2、输入流 InputStreamReader  解码
       =====bytes
       /
    InputStreamReader(字节输入流,"解码集")             OutputStreamWriter(字符输出流,"编码集")
                                                            \
       ======char



==============
双端队列： ArrayDequeue
插入  offerFirst            offerLast
删除  pollFirst             pollLast
获取  peekFirst             peekLast

Collections.synchronized()
Collections.sort( , comparator )
new TreeMap(new Comparator(){ compare})
new TreeSet(new Comparator(){ compare})

一、Hashtable 与HashMap的区别 （面试题）
1、主要:Hashtable线程安全，同步，效率相对低下  synchronized
	HashMap 线程不安全，非同步，效率相对高
2、父类:Hashtable  是 Dictionary  HashMap 是 AbstractMap
3、null: Hashtable键与值不能为null
	HashMap 键最多一个null,值可以多个null
============
为什么要用树
1.有序数组插入和删除数据太慢
2.链表查找数据太慢
3.在树中可以快速的查找 插入 和 删除数据

一棵树只有一个根节点，而且从根节点到任何节点有且只有一条路劲

==================二叉树
树的每个节点最多只能有两个子节点的树，称为二叉树

前序遍历
1.访问根节点
2.前序遍历左子树
3.前序遍历右子树

中序遍历  （遍历后的结果相当于一个有序数组）
1.中序遍历左子树
2.访问根节点
3.中序遍历右子树

后序遍历
1.后序遍历左子树
2.后序遍历右子树
3.访问根节点

删除
1.该节点是叶子节点，没有子节点
要删除叶子节点，只要改变该节点的父节点的引用值，将指向该节点的引用值设为null
2.该节点有一个子节点
改变父节点的引用，将其直接指向要删除节点的子节点
3.该节点有两个子节点
要删除有两个子节点（或者子树）的节点，就需要使用它的中序后继来替代该节点
                5
        3               7
    2       4       6       8
1                               9
其特性如下:
1.每一个结点的值都不同，也就是整棵树中的每一个结点都拥有不同的值 每一个结点的数据大于左子树结点(如果有的话)的数据，
但是小于右子树的结点(如果有的话)的数据。 左右两部分的子树，也是一课二叉查找树。
果想要删除结点后二叉树依然是一棵二叉查找树，可以发现符合这样要求的结点只有两个，那就是4和6.它们是从根结点5的左结点3一直从右子树走到叶子结点和右结点7一直往左子树走一直走到叶子结点。

2.现在我们使用从左子结点开始寻找替换的结点，如果删除的结点是5，就从结点5的左子结点3开始往右子树找，直到达到叶子结点，
找到的是结点4。接着删除此结点，其方法和情况1,2相同，最后取代原结点5成为4。（6也行）

3.如果删除的是结点3，此时左子结点2并没有右子结点，所以符合条件的就是结点2，删除的操作就是成为删除一个没有右子树的结点2，
 然后将原结点3的值取代成为2

=====红黑树
1.普通二叉树相对于随机插入数据，可以快速的插入 删除 查找数据，但是如果插入的数据有序，速度就变得特别慢

2.平衡树和非平衡树
插入随机的数据，平衡树
插入有序的数据，非平衡树

3.红黑规则：
1).每个节点不是红色就是黑色的
2).根总是黑色的
3).如果节点是红色的，则它的子节点必须是黑色的
4).从根节点到叶节点的每条路径，必须包含相同数目的黑色节点

4.纠正规则
1).改变节点的颜色
2).执行旋转操作



====哈希表
1.什么是哈希表
基于数组实现，提供了快速的插入和查找操作

2.哈希化
1）直接将关键字作为索引
2）将单词转换成索引
    a.将字母转换成ASCII码，然后相加
    b.幂的连乘
    c.压缩可选值 （对数组的length取模）

3.压缩后仍然可能出现的问题
    冲突：不能保证每个单词都映射到数值的空白单元
    解决办法：
    a.开放地址法
        当发生冲突时，通过查找数组的一个空位，并将数据填入，而不再用哈希函数得到数组的
        下标
    b.链地址法