1、Index索引

2、少用SELECT *   in   会全表扫描

可能有的人查询数据库时，遇到要查询的都会select，这是不恰当的行为。我们应该取我们要用的数据，而不是全取，因为当我们select时，
会增加web服务器的负担，增加网络传输的负载，查询速度自然就下降 。

3、开启查询缓存

大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。
当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。

4、使用NOT NULL

　　很多表都包含可为NULL（空值）的列，即使应用程序并不需要保存 NULL 也是如此 ，这是因为可为NULL是列的默认属性。
    通常情况下最好指定列为 NOT NULL，除非真的需要存储NULL值。如果查询中包含可为NULL的列，对 MySQL 来说更难优化 ，
    因为可为 NULL 的列使 得索引、索引统计和值比较都更复杂 。可为NULL 的列会使用更多的存储空间 ，在MySQL里也需要特殊处理 。
    当可为NULL 的列被索引肘，每个索引记录需要一个额 外的字节，在 MyISAM 里甚至还可能导致固定大小 的索引
    （例如只有一个整数列的 索引） 变成可变大小的索引。

　　通常把可为 NULL 的列改为 NOT NULL 带来的性能提升比较小 ，所以 （调优时） 没有 必要首先在现有schema中查找井修改掉这种情况 ，除非确定这会导致问题。但是， 如果计划在列上建索引 ，就应该尽量避免设计成可为 NULL 的列。当然也有例外 ，例如值得一提的是，InnoDB 使用单独的位 （bit ） 存储 NULL 值 ，所 以对于稀疏数据由有很好的空间效率 。但这一点不适用于MyISAM 。

5、避免在 where 子句中使用 or 来连接   避免多重嵌套子查询

如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：

select id from t where num=10 or Name = 'admin'
可以这样查询：

select id from t where num = 10
union all
select id from t where Name = 'admin'

6、多使用varchar/nvarchar

使用varchar/nvarchar代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。

7、避免大数据量返回

这里要考虑使用limit，来限制返回的数据量，如果每次返回大量自己不需要的数据，也会降低查询速度。

8、where子句优化

where 子句中使用参数，会导致全表扫描,因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。
然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。 应尽量避免在 where 子句中对字段进行表达式操作，
避免在where子句中对字段进行函数操作这将导致引擎放弃使用索引而进行全表扫描。不要在 where 子句中的“=”左边进行函数、
算术运算或其他表达式运算，否则系统将可能无法正确使用索引。

============
最好不要设置null值，避免sql语句中进行计算，避免In,导致全表扫描